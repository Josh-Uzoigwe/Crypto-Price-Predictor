{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8feeadede1ad5c3abb5a64031b85b219b90be00a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Counter.sol": "project/contracts/Counter.sol",
    "contracts/PredictionMarket.sol": "project/contracts/PredictionMarket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@0.8.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@chainlink/contracts@0.8.0/src/v0.8/interfaces/AggregatorV3Interface.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/Counter.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract Counter {\n  uint public x;\n\n  event Increment(uint by);\n\n  function inc() public {\n    x++;\n    emit Increment(1);\n  }\n\n  function incBy(uint by) public {\n    require(by > 0, \"incBy: increment should be positive\");\n    x += by;\n    emit Increment(by);\n  }\n}\n"
      },
      "project/contracts/PredictionMarket.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n/**\r\n * @title PredictionMarket\r\n * @notice Gas-optimized binary options prediction market for CELO/USD\r\n * @dev Refactored to avoid \"stack too deep\" by splitting logic into helpers.\r\n */\r\ncontract PredictionMarket is Ownable, Pausable, ReentrancyGuard {\r\n    // ============ Errors ============\r\n    error RoundNotOpen();\r\n    error RoundNotLocked();\r\n    error RoundNotEnded();\r\n    error RoundAlreadyExecuted();\r\n    error RoundNotStarted();\r\n    error InvalidEpoch();\r\n    error InvalidAmount();\r\n    error InvalidPriority();\r\n    error NoReward();\r\n    error OraclePriceInvalid();\r\n    error RoundStuck();\r\n    error InvalidAddress();\r\n\r\n    // ============ Constants ============\r\n    uint256 public constant PRECISION = 1e18;\r\n    uint256 public constant TREASURY_FEE_BPS = 100; // 1%\r\n    uint256 public constant MAX_BPS = 10000;\r\n\r\n    uint256 public constant PROPOSAL_FEE_STANDARD = 0.5 ether;\r\n    uint256 public constant PROPOSAL_FEE_HIGH = 2 ether;\r\n    uint256 public constant PROPOSAL_FEE_CRITICAL = 5 ether;\r\n\r\n    // ============ State ============\r\n    AggregatorV3Interface public immutable priceFeed;\r\n\r\n    uint256 public currentEpoch;\r\n    uint256 public roundDuration;\r\n    uint256 public bufferSeconds;\r\n    uint256 public minBetAmount;\r\n\r\n    // Accumulated treasury (in contract) from fees and proposals\r\n    uint256 public treasuryBalance;\r\n\r\n    // epoch => Round\r\n    mapping(uint256 => Round) public rounds;\r\n    // epoch => user => Bet\r\n    mapping(uint256 => mapping(address => Bet)) public ledger;\r\n    // epoch => user => claimed\r\n    mapping(uint256 => mapping(address => bool)) public claimed;\r\n    // user => total claimed (for analytics)\r\n    mapping(address => uint256) public totalClaimed;\r\n\r\n    // ============ Structs & Enums ============\r\n    enum Position { None, Bull, Bear }\r\n\r\n    struct Round {\r\n        uint256 startTime;\r\n        uint256 lockTime;\r\n        uint256 closeTime;\r\n        int256 startPrice;\r\n        int256 lockPrice;\r\n        int256 closePrice;\r\n        uint256 totalAmount;\r\n        uint256 bullAmount;\r\n        uint256 bearAmount;\r\n        uint256 rewardBaseCalAmount;\r\n        uint256 rewardAmount;\r\n        bool executed;\r\n        Position winner;\r\n    }\r\n\r\n    struct Bet {\r\n        Position position;\r\n        uint256 amount;\r\n    }\r\n\r\n    // ============ Events ============\r\n    event BetBull(address indexed sender, uint256 indexed epoch, uint256 amount);\r\n    event BetBear(address indexed sender, uint256 indexed epoch, uint256 amount);\r\n    event StartRound(uint256 indexed epoch);\r\n    event LockRound(uint256 indexed epoch, int256 price);\r\n    event EndRound(uint256 indexed epoch, int256 price, Position winner);\r\n    event Claim(address indexed sender, uint256 indexed epoch, uint256 amount);\r\n    event ClaimMultiple(address indexed sender, uint256[] epochs, uint256 totalAmount);\r\n    event NewRoundDuration(uint256 roundDuration);\r\n    event NewBufferSeconds(uint256 bufferSeconds);\r\n    event NewMinBetAmount(uint256 minBetAmount);\r\n    event ProposalCreated(address indexed proposer, uint8 priority, uint256 amount);\r\n    event RoundCancelled(uint256 indexed epoch);\r\n    event TreasuryWithdrawn(address indexed to, uint256 amount);\r\n    event TreasuryDeposited(uint256 amount);\r\n\r\n    // ============ Constructor (OpenZeppelin v5) ============\r\n    constructor(\r\n        address _priceFeed,\r\n        uint256 _roundDuration,\r\n        uint256 _bufferSeconds,\r\n        uint256 _minBetAmount\r\n    ) Ownable(msg.sender) {\r\n        if (_priceFeed == address(0)) revert InvalidAddress();\r\n        if (_roundDuration == 0) revert InvalidAmount();\r\n        if (_bufferSeconds >= _roundDuration) revert InvalidAmount();\r\n        if (_minBetAmount == 0) revert InvalidAmount();\r\n\r\n        priceFeed = AggregatorV3Interface(_priceFeed);\r\n        roundDuration = _roundDuration;\r\n        bufferSeconds = _bufferSeconds;\r\n        minBetAmount = _minBetAmount;\r\n    }\r\n\r\n    // ============ Modifiers ============\r\n    modifier notContract() {\r\n        if (_isContract(msg.sender)) revert RoundNotOpen();\r\n        _;\r\n    }\r\n\r\n    // ============ External / Public ============\r\n\r\n    /// @notice Start the genesis round (epoch 1)\r\n    function genesisStartRound() external onlyOwner {\r\n        if (currentEpoch != 0) revert RoundAlreadyExecuted(); // genesis already started\r\n        _startRound(1);\r\n    }\r\n\r\n    /// @notice Lock current epoch (record lock price) — anyone can call once lock time passes\r\n    function lockRound() external whenNotPaused {\r\n        if (currentEpoch == 0) revert RoundNotStarted();\r\n        Round storage round = rounds[currentEpoch];\r\n        if (block.timestamp < round.lockTime) revert RoundNotOpen();\r\n        if (round.lockPrice != 0) revert RoundStuck(); // already locked\r\n\r\n        int256 price = _getLatestPrice();\r\n        round.lockPrice = price;\r\n\r\n        emit LockRound(currentEpoch, price);\r\n    }\r\n\r\n    /// @notice Execute the current round, compute winners and start the next round\r\n    function executeRound() external whenNotPaused nonReentrant {\r\n        if (currentEpoch == 0) revert RoundNotStarted();\r\n\r\n        Round storage round = rounds[currentEpoch];\r\n        if (block.timestamp < round.closeTime) revert RoundNotEnded();\r\n        if (round.executed) revert RoundAlreadyExecuted();\r\n        if (round.lockPrice == 0) revert RoundNotLocked();\r\n\r\n        // set close price and executed flag immediately\r\n        round.closePrice = _getLatestPrice();\r\n        round.executed = true;\r\n\r\n        // compute winner & reward accounting using helper to reduce stack pressure\r\n        (Position winner, uint256 rewardAmount, uint256 treasuryAmount, uint256 rewardBase) =\r\n            _determineWinnerAndRewards(currentEpoch);\r\n\r\n        round.winner = winner;\r\n        round.rewardAmount = rewardAmount;\r\n        round.rewardBaseCalAmount = rewardBase;\r\n\r\n        if (treasuryAmount > 0) {\r\n            treasuryBalance += treasuryAmount;\r\n            emit TreasuryDeposited(treasuryAmount);\r\n        }\r\n\r\n        emit EndRound(currentEpoch, round.closePrice, winner);\r\n\r\n        // start next epoch\r\n        _startRound(currentEpoch + 1);\r\n    }\r\n\r\n    /// @notice Place a bet on Bull (price going up)\r\n    function betBull(uint256 epoch) external payable whenNotPaused nonReentrant notContract {\r\n        _placeBet(epoch, Position.Bull);\r\n    }\r\n\r\n    /// @notice Place a bet on Bear (price going down)\r\n    function betBear(uint256 epoch) external payable whenNotPaused nonReentrant notContract {\r\n        _placeBet(epoch, Position.Bear);\r\n    }\r\n\r\n    /// @notice Claim rewards for multiple epochs\r\n    function claim(uint256[] calldata epochs) external nonReentrant {\r\n        uint256 totalReward = 0;\r\n        // iterate and collect\r\n        for (uint256 i = 0; i < epochs.length; ++i) {\r\n            uint256 epoch = epochs[i];\r\n            // handle single epoch claim into helper\r\n            totalReward += _collectForEpoch(epoch, msg.sender);\r\n        }\r\n\r\n        if (totalReward == 0) revert NoReward();\r\n\r\n        totalClaimed[msg.sender] += totalReward;\r\n\r\n        (bool success, ) = payable(msg.sender).call{value: totalReward}(\"\");\r\n        require(success, \"Claim transfer failed\");\r\n\r\n        emit ClaimMultiple(msg.sender, epochs, totalReward);\r\n    }\r\n\r\n    /// @notice Create a governance proposal with priority-based fee\r\n    function createProposal(uint8 priority) external payable whenNotPaused {\r\n        if (priority > 2) revert InvalidPriority();\r\n\r\n        uint256 requiredFee = priority == 0\r\n            ? PROPOSAL_FEE_STANDARD\r\n            : (priority == 1 ? PROPOSAL_FEE_HIGH : PROPOSAL_FEE_CRITICAL);\r\n\r\n        if (msg.value < requiredFee) revert InvalidAmount();\r\n\r\n        // Add requiredFee to treasury\r\n        treasuryBalance += requiredFee;\r\n        emit TreasuryDeposited(requiredFee);\r\n\r\n        // refund any overpayment\r\n        uint256 over = msg.value - requiredFee;\r\n        if (over > 0) {\r\n            (bool refundSuccess, ) = payable(msg.sender).call{value: over}(\"\");\r\n            require(refundSuccess, \"Refund failed\");\r\n        }\r\n\r\n        emit ProposalCreated(msg.sender, priority, requiredFee);\r\n    }\r\n\r\n    /// @notice Cancel a stuck round (owner only)\r\n    function cancelRound(uint256 epoch) external onlyOwner {\r\n        Round storage round = rounds[epoch];\r\n        if (round.executed) revert RoundAlreadyExecuted();\r\n        // require stuck long enough\r\n        if (block.timestamp < round.closeTime + 1 hours) revert RoundStuck();\r\n\r\n        // mark executed and winner none -> refunds allowed via claim\r\n        round.executed = true;\r\n        round.winner = Position.None;\r\n        round.rewardAmount = 0;\r\n        round.rewardBaseCalAmount = 0;\r\n\r\n        emit RoundCancelled(epoch);\r\n    }\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getLatestPrice() external view returns (int256) {\r\n        return _getLatestPrice();\r\n    }\r\n\r\n    function getRound(uint256 epoch) external view returns (Round memory) {\r\n        return rounds[epoch];\r\n    }\r\n\r\n    function getUserBet(uint256 epoch, address user) external view returns (Bet memory) {\r\n        return ledger[epoch][user];\r\n    }\r\n\r\n    function hasClaimed(uint256 epoch, address user) external view returns (bool) {\r\n        return claimed[epoch][user];\r\n    }\r\n\r\n    function isRoundOpen(uint256 epoch) external view returns (bool) {\r\n        Round memory round = rounds[epoch];\r\n        return block.timestamp >= round.startTime && block.timestamp < round.lockTime && !round.executed;\r\n    }\r\n\r\n    function isRoundLocked(uint256 epoch) external view returns (bool) {\r\n        Round memory round = rounds[epoch];\r\n        return block.timestamp >= round.lockTime && round.lockPrice != 0 && !round.executed;\r\n    }\r\n\r\n    function getTreasuryBalance() external view returns (uint256) {\r\n        return treasuryBalance;\r\n    }\r\n\r\n    // ============ Internal Functions ============\r\n\r\n    /// @dev Determine winner & compute reward + treasury amounts (minimizes locals)\r\n    function _determineWinnerAndRewards(uint256 epoch) internal view returns (\r\n        Position winner,\r\n        uint256 rewardAmount,\r\n        uint256 treasuryAmount,\r\n        uint256 rewardBase\r\n    ) {\r\n        Round storage r = rounds[epoch];\r\n\r\n        // default\r\n        winner = Position.None;\r\n        rewardAmount = 0;\r\n        treasuryAmount = 0;\r\n        rewardBase = 0;\r\n\r\n        // determine winner\r\n        if (r.closePrice > r.startPrice) winner = Position.Bull;\r\n        else if (r.closePrice < r.startPrice) winner = Position.Bear;\r\n        else return (winner, 0, 0, 0); // tie\r\n\r\n        // no bets at all\r\n        if (r.totalAmount == 0) return (winner, 0, 0, 0);\r\n\r\n        if (winner == Position.Bull && r.bullAmount > 0) {\r\n            uint256 losing = r.bearAmount;\r\n            treasuryAmount = (losing * TREASURY_FEE_BPS) / MAX_BPS;\r\n            rewardAmount = losing - treasuryAmount;\r\n            rewardBase = r.bullAmount;\r\n            return (winner, rewardAmount, treasuryAmount, rewardBase);\r\n        }\r\n\r\n        if (winner == Position.Bear && r.bearAmount > 0) {\r\n            uint256 losing = r.bullAmount;\r\n            treasuryAmount = (losing * TREASURY_FEE_BPS) / MAX_BPS;\r\n            rewardAmount = losing - treasuryAmount;\r\n            rewardBase = r.bearAmount;\r\n            return (winner, rewardAmount, treasuryAmount, rewardBase);\r\n        }\r\n\r\n        // fallback - no winners or no bets on winning side\r\n        return (winner, 0, 0, 0);\r\n    }\r\n\r\n    /// @dev Start a new round (internal)\r\n    function _startRound(uint256 epoch) internal {\r\n        int256 currentPrice = _getLatestPrice();\r\n\r\n        Round storage round = rounds[epoch];\r\n        round.startTime = block.timestamp;\r\n        round.lockTime = block.timestamp + (roundDuration - bufferSeconds);\r\n        round.closeTime = block.timestamp + roundDuration;\r\n        round.startPrice = currentPrice;\r\n\r\n        // reset other fields just in case (safe)\r\n        round.lockPrice = 0;\r\n        round.closePrice = 0;\r\n        round.totalAmount = 0;\r\n        round.bullAmount = 0;\r\n        round.bearAmount = 0;\r\n        round.rewardBaseCalAmount = 0;\r\n        round.rewardAmount = 0;\r\n        round.executed = false;\r\n        round.winner = Position.None;\r\n\r\n        currentEpoch = epoch;\r\n\r\n        emit StartRound(epoch);\r\n    }\r\n\r\n    /// @dev Place bet (internal) — reduced locals\r\n    function _placeBet(uint256 epoch, Position position) internal {\r\n        if (epoch != currentEpoch) revert InvalidEpoch();\r\n        Round storage round = rounds[epoch];\r\n\r\n        if (block.timestamp < round.startTime || block.timestamp >= round.lockTime) {\r\n            revert RoundNotOpen();\r\n        }\r\n\r\n        if (msg.value < minBetAmount) revert InvalidAmount();\r\n        if (round.executed) revert RoundNotOpen();\r\n        if (position == Position.None) revert InvalidAmount();\r\n\r\n        Bet storage bet = ledger[epoch][msg.sender];\r\n\r\n        // If user already placed a bet, ensure they do not switch sides mid-round\r\n        if (bet.amount > 0) {\r\n            if (bet.position != position) revert InvalidAmount(); // cannot change position during same epoch\r\n            // else allowed to increase amount\r\n        } else {\r\n            bet.position = position;\r\n        }\r\n\r\n        // update amounts (single updates to reduce temporaries)\r\n        bet.amount += msg.value;\r\n        round.totalAmount += msg.value;\r\n\r\n        if (position == Position.Bull) {\r\n            round.bullAmount += msg.value;\r\n            emit BetBull(msg.sender, epoch, msg.value);\r\n        } else {\r\n            round.bearAmount += msg.value;\r\n            emit BetBear(msg.sender, epoch, msg.value);\r\n        }\r\n    }\r\n\r\n    /// @dev Collect reward/refund for a single epoch for a single user.\r\n    /// Returns the amount collectible (0 if nothing) and marks as claimed where applicable.\r\n    function _collectForEpoch(uint256 epoch, address user) internal returns (uint256) {\r\n        Round memory r = rounds[epoch];\r\n\r\n        // must be executed before claiming\r\n        if (!r.executed) return 0;\r\n        if (claimed[epoch][user]) return 0;\r\n\r\n        Bet memory userBet = ledger[epoch][user];\r\n        if (userBet.amount == 0) return 0;\r\n\r\n        // Refund on tie or cancellation\r\n        if (r.winner == Position.None) {\r\n            claimed[epoch][user] = true;\r\n            emit Claim(user, epoch, userBet.amount);\r\n            return userBet.amount;\r\n        }\r\n\r\n        // If user didn't choose winning side\r\n        if (userBet.position != r.winner) {\r\n            // nothing to claim\r\n            return 0;\r\n        }\r\n\r\n        if (r.rewardBaseCalAmount == 0) {\r\n            // defensive: no base to calculate from\r\n            claimed[epoch][user] = true;\r\n            return 0;\r\n        }\r\n\r\n        // compute proportional reward\r\n        uint256 reward = (userBet.amount * r.rewardAmount) / r.rewardBaseCalAmount;\r\n        if (reward == 0) {\r\n            claimed[epoch][user] = true;\r\n            return 0;\r\n        }\r\n\r\n        claimed[epoch][user] = true;\r\n        emit Claim(user, epoch, reward);\r\n        return reward;\r\n    }\r\n\r\n    /// @dev Get latest Chainlink price & perform sanity checks\r\n    function _getLatestPrice() internal view returns (int256) {\r\n        (, int256 price, , uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\r\n\r\n        if (price <= 0) revert OraclePriceInvalid();\r\n        if (updatedAt == 0) revert OraclePriceInvalid();\r\n        if (block.timestamp - updatedAt >= 1 hours) revert OraclePriceInvalid();\r\n        if (answeredInRound == 0) revert OraclePriceInvalid();\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev primitive contract check\r\n    function _isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    // ============ Admin Functions ============\r\n\r\n    function setRoundDuration(uint256 _roundDuration) external onlyOwner {\r\n        if (_roundDuration == 0) revert InvalidAmount();\r\n        roundDuration = _roundDuration;\r\n        emit NewRoundDuration(_roundDuration);\r\n    }\r\n\r\n    function setBufferSeconds(uint256 _bufferSeconds) external onlyOwner {\r\n        if (_bufferSeconds >= roundDuration) revert InvalidAmount();\r\n        bufferSeconds = _bufferSeconds;\r\n        emit NewBufferSeconds(_bufferSeconds);\r\n    }\r\n\r\n    function setMinBetAmount(uint256 _minBetAmount) external onlyOwner {\r\n        if (_minBetAmount == 0) revert InvalidAmount();\r\n        minBetAmount = _minBetAmount;\r\n        emit NewMinBetAmount(_minBetAmount);\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function withdrawTreasury(address payable to, uint256 amount) external onlyOwner {\r\n        if (to == address(0)) revert InvalidAddress();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (treasuryBalance < amount) revert NoReward();\r\n\r\n        treasuryBalance -= amount;\r\n        (bool success, ) = to.call{value: amount}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n\r\n        emit TreasuryWithdrawn(to, amount);\r\n    }\r\n\r\n    // ============ Receive / Fallback ============\r\n    receive() external payable {\r\n        if (msg.value > 0) {\r\n            treasuryBalance += msg.value;\r\n            emit TreasuryDeposited(msg.value);\r\n        }\r\n    }\r\n\r\n    fallback() external payable {\r\n        if (msg.value > 0) {\r\n            treasuryBalance += msg.value;\r\n            emit TreasuryDeposited(msg.value);\r\n        }\r\n    }\r\n}\r\n"
      }
    }
  }
}